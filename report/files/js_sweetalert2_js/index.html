<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - js/sweetalert2.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>js/sweetalert2.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">68.70</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">3179</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">130.27</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">37.76</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
* sweetalert2 v9.17.2
* Released under the MIT License.
*/
(function (global, factory) {
  typeof exports === &#039;object&#039; &amp;&amp; typeof module !== &#039;undefined&#039; ? module.exports = factory() :
  typeof define === &#039;function&#039; &amp;&amp; define.amd ? define(factory) :
  (global = global || self, global.Sweetalert2 = factory());
}(this, function () { &#039;use strict&#039;;

  function _typeof(obj) {
    &quot;@babel/helpers - typeof&quot;;

    if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError(&quot;Cannot call a class as a function&quot;);
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i &lt; props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if (&quot;value&quot; in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i &lt; arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) {
      throw new TypeError(&quot;Super expression must either be null or a function&quot;);
    }

    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === &quot;undefined&quot; || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === &quot;function&quot;) return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError(&quot;this hasn&#039;t been initialised - super() hasn&#039;t been called&quot;);
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;)) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== &quot;undefined&quot; &amp;&amp; Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var consolePrefix = &#039;SweetAlert2:&#039;;
  /**
   * Filter the unique values into a new array
   * @param arr
   */

  var uniqueArray = function uniqueArray(arr) {
    var result = [];

    for (var i = 0; i &lt; arr.length; i++) {
      if (result.indexOf(arr[i]) === -1) {
        result.push(arr[i]);
      }
    }

    return result;
  };
  /**
   * Capitalize the first letter of a string
   * @param str
   */

  var capitalizeFirstLetter = function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  /**
   * Returns the array of object values (Object.values isn&#039;t supported in IE11)
   * @param obj
   */

  var objectValues = function objectValues(obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  };
  /**
   * Convert NodeList to Array
   * @param nodeList
   */

  var toArray = function toArray(nodeList) {
    return Array.prototype.slice.call(nodeList);
  };
  /**
   * Standardise console warnings
   * @param message
   */

  var warn = function warn(message) {
    console.warn(&quot;&quot;.concat(consolePrefix, &quot; &quot;).concat(message));
  };
  /**
   * Standardise console errors
   * @param message
   */

  var error = function error(message) {
    console.error(&quot;&quot;.concat(consolePrefix, &quot; &quot;).concat(message));
  };
  /**
   * Private global state for `warnOnce`
   * @type {Array}
   * @private
   */

  var previousWarnOnceMessages = [];
  /**
   * Show a console warning, but only if it hasn&#039;t already been shown
   * @param message
   */

  var warnOnce = function warnOnce(message) {
    if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {
      previousWarnOnceMessages.push(message);
      warn(message);
    }
  };
  /**
   * Show a one-time console warning about deprecated params/methods
   */

  var warnAboutDepreation = function warnAboutDepreation(deprecatedParam, useInstead) {
    warnOnce(&quot;\&quot;&quot;.concat(deprecatedParam, &quot;\&quot; is deprecated and will be removed in the next major release. Please use \&quot;&quot;).concat(useInstead, &quot;\&quot; instead.&quot;));
  };
  /**
   * If `arg` is a function, call it (with no arguments or context) and return the result.
   * Otherwise, just pass the value through
   * @param arg
   */

  var callIfFunction = function callIfFunction(arg) {
    return typeof arg === &#039;function&#039; ? arg() : arg;
  };
  var hasToPromiseFn = function hasToPromiseFn(arg) {
    return arg &amp;&amp; typeof arg.toPromise === &#039;function&#039;;
  };
  var asPromise = function asPromise(arg) {
    return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
  };
  var isPromise = function isPromise(arg) {
    return arg &amp;&amp; Promise.resolve(arg) === arg;
  };

  var DismissReason = Object.freeze({
    cancel: &#039;cancel&#039;,
    backdrop: &#039;backdrop&#039;,
    close: &#039;close&#039;,
    esc: &#039;esc&#039;,
    timer: &#039;timer&#039;
  });

  var isJqueryElement = function isJqueryElement(elem) {
    return _typeof(elem) === &#039;object&#039; &amp;&amp; elem.jquery;
  };

  var isElement = function isElement(elem) {
    return elem instanceof Element || isJqueryElement(elem);
  };

  var argsToParams = function argsToParams(args) {
    var params = {};

    if (_typeof(args[0]) === &#039;object&#039; &amp;&amp; !isElement(args[0])) {
      _extends(params, args[0]);
    } else {
      [&#039;title&#039;, &#039;html&#039;, &#039;icon&#039;].forEach(function (name, index) {
        var arg = args[index];

        if (typeof arg === &#039;string&#039; || isElement(arg)) {
          params[name] = arg;
        } else if (arg !== undefined) {
          error(&quot;Unexpected type of &quot;.concat(name, &quot;! Expected \&quot;string\&quot; or \&quot;Element\&quot;, got &quot;).concat(_typeof(arg)));
        }
      });
    }

    return params;
  };

  var swalPrefix = &#039;swal2-&#039;;
  var prefix = function prefix(items) {
    var result = {};

    for (var i in items) {
      result[items[i]] = swalPrefix + items[i];
    }

    return result;
  };
  var swalClasses = prefix([&#039;container&#039;, &#039;shown&#039;, &#039;height-auto&#039;, &#039;iosfix&#039;, &#039;popup&#039;, &#039;modal&#039;, &#039;no-backdrop&#039;, &#039;no-transition&#039;, &#039;toast&#039;, &#039;toast-shown&#039;, &#039;toast-column&#039;, &#039;show&#039;, &#039;hide&#039;, &#039;close&#039;, &#039;title&#039;, &#039;header&#039;, &#039;content&#039;, &#039;html-container&#039;, &#039;actions&#039;, &#039;confirm&#039;, &#039;cancel&#039;, &#039;footer&#039;, &#039;icon&#039;, &#039;icon-content&#039;, &#039;image&#039;, &#039;input&#039;, &#039;file&#039;, &#039;range&#039;, &#039;select&#039;, &#039;radio&#039;, &#039;checkbox&#039;, &#039;label&#039;, &#039;textarea&#039;, &#039;inputerror&#039;, &#039;validation-message&#039;, &#039;progress-steps&#039;, &#039;active-progress-step&#039;, &#039;progress-step&#039;, &#039;progress-step-line&#039;, &#039;loading&#039;, &#039;styled&#039;, &#039;top&#039;, &#039;top-start&#039;, &#039;top-end&#039;, &#039;top-left&#039;, &#039;top-right&#039;, &#039;center&#039;, &#039;center-start&#039;, &#039;center-end&#039;, &#039;center-left&#039;, &#039;center-right&#039;, &#039;bottom&#039;, &#039;bottom-start&#039;, &#039;bottom-end&#039;, &#039;bottom-left&#039;, &#039;bottom-right&#039;, &#039;grow-row&#039;, &#039;grow-column&#039;, &#039;grow-fullscreen&#039;, &#039;rtl&#039;, &#039;timer-progress-bar&#039;, &#039;timer-progress-bar-container&#039;, &#039;scrollbar-measure&#039;, &#039;icon-success&#039;, &#039;icon-warning&#039;, &#039;icon-info&#039;, &#039;icon-question&#039;, &#039;icon-error&#039;]);
  var iconTypes = prefix([&#039;success&#039;, &#039;warning&#039;, &#039;info&#039;, &#039;question&#039;, &#039;error&#039;]);

  var getContainer = function getContainer() {
    return document.body.querySelector(&quot;.&quot;.concat(swalClasses.container));
  };
  var elementBySelector = function elementBySelector(selectorString) {
    var container = getContainer();
    return container ? container.querySelector(selectorString) : null;
  };

  var elementByClass = function elementByClass(className) {
    return elementBySelector(&quot;.&quot;.concat(className));
  };

  var getPopup = function getPopup() {
    return elementByClass(swalClasses.popup);
  };
  var getIcons = function getIcons() {
    var popup = getPopup();
    return toArray(popup.querySelectorAll(&quot;.&quot;.concat(swalClasses.icon)));
  };
  var getIcon = function getIcon() {
    var visibleIcon = getIcons().filter(function (icon) {
      return isVisible(icon);
    });
    return visibleIcon.length ? visibleIcon[0] : null;
  };
  var getTitle = function getTitle() {
    return elementByClass(swalClasses.title);
  };
  var getContent = function getContent() {
    return elementByClass(swalClasses.content);
  };
  var getHtmlContainer = function getHtmlContainer() {
    return elementByClass(swalClasses[&#039;html-container&#039;]);
  };
  var getImage = function getImage() {
    return elementByClass(swalClasses.image);
  };
  var getProgressSteps = function getProgressSteps() {
    return elementByClass(swalClasses[&#039;progress-steps&#039;]);
  };
  var getValidationMessage = function getValidationMessage() {
    return elementByClass(swalClasses[&#039;validation-message&#039;]);
  };
  var getConfirmButton = function getConfirmButton() {
    return elementBySelector(&quot;.&quot;.concat(swalClasses.actions, &quot; .&quot;).concat(swalClasses.confirm));
  };
  var getCancelButton = function getCancelButton() {
    return elementBySelector(&quot;.&quot;.concat(swalClasses.actions, &quot; .&quot;).concat(swalClasses.cancel));
  };
  var getActions = function getActions() {
    return elementByClass(swalClasses.actions);
  };
  var getHeader = function getHeader() {
    return elementByClass(swalClasses.header);
  };
  var getFooter = function getFooter() {
    return elementByClass(swalClasses.footer);
  };
  var getTimerProgressBar = function getTimerProgressBar() {
    return elementByClass(swalClasses[&#039;timer-progress-bar&#039;]);
  };
  var getCloseButton = function getCloseButton() {
    return elementByClass(swalClasses.close);
  }; // https://github.com/jkup/focusable/blob/master/index.js

  var focusable = &quot;\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\&quot;0\&quot;],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n&quot;;
  var getFocusableElements = function getFocusableElements() {
    var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll(&#039;[tabindex]:not([tabindex=&quot;-1&quot;]):not([tabindex=&quot;0&quot;])&#039;)) // sort according to tabindex
    .sort(function (a, b) {
      a = parseInt(a.getAttribute(&#039;tabindex&#039;));
      b = parseInt(b.getAttribute(&#039;tabindex&#039;));

      if (a &gt; b) {
        return 1;
      } else if (a &lt; b) {
        return -1;
      }

      return 0;
    });
    var otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter(function (el) {
      return el.getAttribute(&#039;tabindex&#039;) !== &#039;-1&#039;;
    });
    return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {
      return isVisible(el);
    });
  };
  var isModal = function isModal() {
    return !isToast() &amp;&amp; !document.body.classList.contains(swalClasses[&#039;no-backdrop&#039;]);
  };
  var isToast = function isToast() {
    return document.body.classList.contains(swalClasses[&#039;toast-shown&#039;]);
  };
  var isLoading = function isLoading() {
    return getPopup().hasAttribute(&#039;data-loading&#039;);
  };

  var states = {
    previousBodyPadding: null
  };
  var setInnerHtml = function setInnerHtml(elem, html) {
    // #1926
    elem.textContent = &#039;&#039;;

    if (html) {
      var parser = new DOMParser();
      var parsed = parser.parseFromString(html, &quot;text/html&quot;);
      toArray(parsed.querySelector(&#039;head&#039;).childNodes).forEach(function (child) {
        elem.appendChild(child);
      });
      toArray(parsed.querySelector(&#039;body&#039;).childNodes).forEach(function (child) {
        elem.appendChild(child);
      });
    }
  };
  var hasClass = function hasClass(elem, className) {
    if (!className) {
      return false;
    }

    var classList = className.split(/\s+/);

    for (var i = 0; i &lt; classList.length; i++) {
      if (!elem.classList.contains(classList[i])) {
        return false;
      }
    }

    return true;
  };

  var removeCustomClasses = function removeCustomClasses(elem, params) {
    toArray(elem.classList).forEach(function (className) {
      if (!(objectValues(swalClasses).indexOf(className) !== -1) &amp;&amp; !(objectValues(iconTypes).indexOf(className) !== -1) &amp;&amp; !(objectValues(params.showClass).indexOf(className) !== -1)) {
        elem.classList.remove(className);
      }
    });
  };

  var applyCustomClass = function applyCustomClass(elem, params, className) {
    removeCustomClasses(elem, params);

    if (params.customClass &amp;&amp; params.customClass[className]) {
      if (typeof params.customClass[className] !== &#039;string&#039; &amp;&amp; !params.customClass[className].forEach) {
        return warn(&quot;Invalid type of customClass.&quot;.concat(className, &quot;! Expected string or iterable object, got \&quot;&quot;).concat(_typeof(params.customClass[className]), &quot;\&quot;&quot;));
      }

      addClass(elem, params.customClass[className]);
    }
  };
  function getInput(content, inputType) {
    if (!inputType) {
      return null;
    }

    switch (inputType) {
      case &#039;select&#039;:
      case &#039;textarea&#039;:
      case &#039;file&#039;:
        return getChildByClass(content, swalClasses[inputType]);

      case &#039;checkbox&#039;:
        return content.querySelector(&quot;.&quot;.concat(swalClasses.checkbox, &quot; input&quot;));

      case &#039;radio&#039;:
        return content.querySelector(&quot;.&quot;.concat(swalClasses.radio, &quot; input:checked&quot;)) || content.querySelector(&quot;.&quot;.concat(swalClasses.radio, &quot; input:first-child&quot;));

      case &#039;range&#039;:
        return content.querySelector(&quot;.&quot;.concat(swalClasses.range, &quot; input&quot;));

      default:
        return getChildByClass(content, swalClasses.input);
    }
  }
  var focusInput = function focusInput(input) {
    input.focus(); // place cursor at end of text in text input

    if (input.type !== &#039;file&#039;) {
      // http://stackoverflow.com/a/2345915
      var val = input.value;
      input.value = &#039;&#039;;
      input.value = val;
    }
  };
  var toggleClass = function toggleClass(target, classList, condition) {
    if (!target || !classList) {
      return;
    }

    if (typeof classList === &#039;string&#039;) {
      classList = classList.split(/\s+/).filter(Boolean);
    }

    classList.forEach(function (className) {
      if (target.forEach) {
        target.forEach(function (elem) {
          condition ? elem.classList.add(className) : elem.classList.remove(className);
        });
      } else {
        condition ? target.classList.add(className) : target.classList.remove(className);
      }
    });
  };
  var addClass = function addClass(target, classList) {
    toggleClass(target, classList, true);
  };
  var removeClass = function removeClass(target, classList) {
    toggleClass(target, classList, false);
  };
  var getChildByClass = function getChildByClass(elem, className) {
    for (var i = 0; i &lt; elem.childNodes.length; i++) {
      if (hasClass(elem.childNodes[i], className)) {
        return elem.childNodes[i];
      }
    }
  };
  var applyNumericalStyle = function applyNumericalStyle(elem, property, value) {
    if (value || parseInt(value) === 0) {
      elem.style[property] = typeof value === &#039;number&#039; ? &quot;&quot;.concat(value, &quot;px&quot;) : value;
    } else {
      elem.style.removeProperty(property);
    }
  };
  var show = function show(elem) {
    var display = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &#039;flex&#039;;
    elem.style.opacity = &#039;&#039;;
    elem.style.display = display;
  };
  var hide = function hide(elem) {
    elem.style.opacity = &#039;&#039;;
    elem.style.display = &#039;none&#039;;
  };
  var toggle = function toggle(elem, condition, display) {
    condition ? show(elem, display) : hide(elem);
  }; // borrowed from jquery $(elem).is(&#039;:visible&#039;) implementation

  var isVisible = function isVisible(elem) {
    return !!(elem &amp;&amp; (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
  };
  /* istanbul ignore next */

  var isScrollable = function isScrollable(elem) {
    return !!(elem.scrollHeight &gt; elem.clientHeight);
  }; // borrowed from https://stackoverflow.com/a/46352119

  var hasCssAnimation = function hasCssAnimation(elem) {
    var style = window.getComputedStyle(elem);
    var animDuration = parseFloat(style.getPropertyValue(&#039;animation-duration&#039;) || &#039;0&#039;);
    var transDuration = parseFloat(style.getPropertyValue(&#039;transition-duration&#039;) || &#039;0&#039;);
    return animDuration &gt; 0 || transDuration &gt; 0;
  };
  var contains = function contains(haystack, needle) {
    if (typeof haystack.contains === &#039;function&#039;) {
      return haystack.contains(needle);
    }
  };
  var animateTimerProgressBar = function animateTimerProgressBar(timer) {
    var reset = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;
    var timerProgressBar = getTimerProgressBar();

    if (isVisible(timerProgressBar)) {
      if (reset) {
        timerProgressBar.style.transition = &#039;none&#039;;
        timerProgressBar.style.width = &#039;100%&#039;;
      }

      setTimeout(function () {
        timerProgressBar.style.transition = &quot;width &quot;.concat(timer / 1000, &quot;s linear&quot;);
        timerProgressBar.style.width = &#039;0%&#039;;
      }, 10);
    }
  };
  var stopTimerProgressBar = function stopTimerProgressBar() {
    var timerProgressBar = getTimerProgressBar();
    var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    timerProgressBar.style.removeProperty(&#039;transition&#039;);
    timerProgressBar.style.width = &#039;100%&#039;;
    var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
    var timerProgressBarPercent = parseInt(timerProgressBarWidth / timerProgressBarFullWidth * 100);
    timerProgressBar.style.removeProperty(&#039;transition&#039;);
    timerProgressBar.style.width = &quot;&quot;.concat(timerProgressBarPercent, &quot;%&quot;);
  };

  // Detect Node env
  var isNodeEnv = function isNodeEnv() {
    return typeof window === &#039;undefined&#039; || typeof document === &#039;undefined&#039;;
  };

  var sweetHTML = &quot;\n &lt;div aria-labelledby=\&quot;&quot;.concat(swalClasses.title, &quot;\&quot; aria-describedby=\&quot;&quot;).concat(swalClasses.content, &quot;\&quot; class=\&quot;&quot;).concat(swalClasses.popup, &quot;\&quot; tabindex=\&quot;-1\&quot;&gt;\n   &lt;div class=\&quot;&quot;).concat(swalClasses.header, &quot;\&quot;&gt;\n     &lt;ul class=\&quot;&quot;).concat(swalClasses[&#039;progress-steps&#039;], &quot;\&quot;&gt;&lt;/ul&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses.icon, &quot; &quot;).concat(iconTypes.error, &quot;\&quot;&gt;&lt;/div&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses.icon, &quot; &quot;).concat(iconTypes.question, &quot;\&quot;&gt;&lt;/div&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses.icon, &quot; &quot;).concat(iconTypes.warning, &quot;\&quot;&gt;&lt;/div&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses.icon, &quot; &quot;).concat(iconTypes.info, &quot;\&quot;&gt;&lt;/div&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses.icon, &quot; &quot;).concat(iconTypes.success, &quot;\&quot;&gt;&lt;/div&gt;\n     &lt;img class=\&quot;&quot;).concat(swalClasses.image, &quot;\&quot; /&gt;\n     &lt;h2 class=\&quot;&quot;).concat(swalClasses.title, &quot;\&quot; id=\&quot;&quot;).concat(swalClasses.title, &quot;\&quot;&gt;&lt;/h2&gt;\n     &lt;button type=\&quot;button\&quot; class=\&quot;&quot;).concat(swalClasses.close, &quot;\&quot;&gt;&lt;/button&gt;\n   &lt;/div&gt;\n   &lt;div class=\&quot;&quot;).concat(swalClasses.content, &quot;\&quot;&gt;\n     &lt;div id=\&quot;&quot;).concat(swalClasses.content, &quot;\&quot; class=\&quot;&quot;).concat(swalClasses[&#039;html-container&#039;], &quot;\&quot;&gt;&lt;/div&gt;\n     &lt;input class=\&quot;&quot;).concat(swalClasses.input, &quot;\&quot; /&gt;\n     &lt;input type=\&quot;file\&quot; class=\&quot;&quot;).concat(swalClasses.file, &quot;\&quot; /&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses.range, &quot;\&quot;&gt;\n       &lt;input type=\&quot;range\&quot; /&gt;\n       &lt;output&gt;&lt;/output&gt;\n     &lt;/div&gt;\n     &lt;select class=\&quot;&quot;).concat(swalClasses.select, &quot;\&quot;&gt;&lt;/select&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses.radio, &quot;\&quot;&gt;&lt;/div&gt;\n     &lt;label for=\&quot;&quot;).concat(swalClasses.checkbox, &quot;\&quot; class=\&quot;&quot;).concat(swalClasses.checkbox, &quot;\&quot;&gt;\n       &lt;input type=\&quot;checkbox\&quot; /&gt;\n       &lt;span class=\&quot;&quot;).concat(swalClasses.label, &quot;\&quot;&gt;&lt;/span&gt;\n     &lt;/label&gt;\n     &lt;textarea class=\&quot;&quot;).concat(swalClasses.textarea, &quot;\&quot;&gt;&lt;/textarea&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses[&#039;validation-message&#039;], &quot;\&quot; id=\&quot;&quot;).concat(swalClasses[&#039;validation-message&#039;], &quot;\&quot;&gt;&lt;/div&gt;\n   &lt;/div&gt;\n   &lt;div class=\&quot;&quot;).concat(swalClasses.actions, &quot;\&quot;&gt;\n     &lt;button type=\&quot;button\&quot; class=\&quot;&quot;).concat(swalClasses.confirm, &quot;\&quot;&gt;OK&lt;/button&gt;\n     &lt;button type=\&quot;button\&quot; class=\&quot;&quot;).concat(swalClasses.cancel, &quot;\&quot;&gt;Cancel&lt;/button&gt;\n   &lt;/div&gt;\n   &lt;div class=\&quot;&quot;).concat(swalClasses.footer, &quot;\&quot;&gt;&lt;/div&gt;\n   &lt;div class=\&quot;&quot;).concat(swalClasses[&#039;timer-progress-bar-container&#039;], &quot;\&quot;&gt;\n     &lt;div class=\&quot;&quot;).concat(swalClasses[&#039;timer-progress-bar&#039;], &quot;\&quot;&gt;&lt;/div&gt;\n   &lt;/div&gt;\n &lt;/div&gt;\n&quot;).replace(/(^|\n)\s*/g, &#039;&#039;);

  var resetOldContainer = function resetOldContainer() {
    var oldContainer = getContainer();

    if (!oldContainer) {
      return false;
    }

    oldContainer.parentNode.removeChild(oldContainer);
    removeClass([document.documentElement, document.body], [swalClasses[&#039;no-backdrop&#039;], swalClasses[&#039;toast-shown&#039;], swalClasses[&#039;has-column&#039;]]);
    return true;
  };

  var oldInputVal; // IE11 workaround, see #1109 for details

  var resetValidationMessage = function resetValidationMessage(e) {
    if (Swal.isVisible() &amp;&amp; oldInputVal !== e.target.value) {
      Swal.resetValidationMessage();
    }

    oldInputVal = e.target.value;
  };

  var addInputChangeListeners = function addInputChangeListeners() {
    var content = getContent();
    var input = getChildByClass(content, swalClasses.input);
    var file = getChildByClass(content, swalClasses.file);
    var range = content.querySelector(&quot;.&quot;.concat(swalClasses.range, &quot; input&quot;));
    var rangeOutput = content.querySelector(&quot;.&quot;.concat(swalClasses.range, &quot; output&quot;));
    var select = getChildByClass(content, swalClasses.select);
    var checkbox = content.querySelector(&quot;.&quot;.concat(swalClasses.checkbox, &quot; input&quot;));
    var textarea = getChildByClass(content, swalClasses.textarea);
    input.oninput = resetValidationMessage;
    file.onchange = resetValidationMessage;
    select.onchange = resetValidationMessage;
    checkbox.onchange = resetValidationMessage;
    textarea.oninput = resetValidationMessage;

    range.oninput = function (e) {
      resetValidationMessage(e);
      rangeOutput.value = range.value;
    };

    range.onchange = function (e) {
      resetValidationMessage(e);
      range.nextSibling.value = range.value;
    };
  };

  var getTarget = function getTarget(target) {
    return typeof target === &#039;string&#039; ? document.querySelector(target) : target;
  };

  var setupAccessibility = function setupAccessibility(params) {
    var popup = getPopup();
    popup.setAttribute(&#039;role&#039;, params.toast ? &#039;alert&#039; : &#039;dialog&#039;);
    popup.setAttribute(&#039;aria-live&#039;, params.toast ? &#039;polite&#039; : &#039;assertive&#039;);

    if (!params.toast) {
      popup.setAttribute(&#039;aria-modal&#039;, &#039;true&#039;);
    }
  };

  var setupRTL = function setupRTL(targetElement) {
    if (window.getComputedStyle(targetElement).direction === &#039;rtl&#039;) {
      addClass(getContainer(), swalClasses.rtl);
    }
  };
  /*
   * Add modal + backdrop to DOM
   */


  var init = function init(params) {
    // Clean up the old popup container if it exists
    var oldContainerExisted = resetOldContainer();
    /* istanbul ignore if */

    if (isNodeEnv()) {
      error(&#039;SweetAlert2 requires document to initialize&#039;);
      return;
    }

    var container = document.createElement(&#039;div&#039;);
    container.className = swalClasses.container;

    if (oldContainerExisted) {
      addClass(container, swalClasses[&#039;no-transition&#039;]);
    }

    setInnerHtml(container, sweetHTML);
    var targetElement = getTarget(params.target);
    targetElement.appendChild(container);
    setupAccessibility(params);
    setupRTL(targetElement);
    addInputChangeListeners();
  };

  var parseHtmlToContainer = function parseHtmlToContainer(param, target) {
    // DOM element
    if (param instanceof HTMLElement) {
      target.appendChild(param); // Object
    } else if (_typeof(param) === &#039;object&#039;) {
      handleObject(param, target); // Plain string
    } else if (param) {
      setInnerHtml(target, param);
    }
  };

  var handleObject = function handleObject(param, target) {
    // JQuery element(s)
    if (param.jquery) {
      handleJqueryElem(target, param); // For other objects use their string representation
    } else {
      setInnerHtml(target, param.toString());
    }
  };

  var handleJqueryElem = function handleJqueryElem(target, elem) {
    target.textContent = &#039;&#039;;

    if (0 in elem) {
      for (var i = 0; (i in elem); i++) {
        target.appendChild(elem[i].cloneNode(true));
      }
    } else {
      target.appendChild(elem.cloneNode(true));
    }
  };

  var animationEndEvent = function () {
    // Prevent run in Node env

    /* istanbul ignore if */
    if (isNodeEnv()) {
      return false;
    }

    var testEl = document.createElement(&#039;div&#039;);
    var transEndEventNames = {
      WebkitAnimation: &#039;webkitAnimationEnd&#039;,
      OAnimation: &#039;oAnimationEnd oanimationend&#039;,
      animation: &#039;animationend&#039;
    };

    for (var i in transEndEventNames) {
      if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) &amp;&amp; typeof testEl.style[i] !== &#039;undefined&#039;) {
        return transEndEventNames[i];
      }
    }

    return false;
  }();

  // https://github.com/twbs/bootstrap/blob/master/js/src/modal.js

  var measureScrollbar = function measureScrollbar() {
    var scrollDiv = document.createElement(&#039;div&#039;);
    scrollDiv.className = swalClasses[&#039;scrollbar-measure&#039;];
    document.body.appendChild(scrollDiv);
    var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
  };

  var renderActions = function renderActions(instance, params) {
    var actions = getActions();
    var confirmButton = getConfirmButton();
    var cancelButton = getCancelButton(); // Actions (buttons) wrapper

    if (!params.showConfirmButton &amp;&amp; !params.showCancelButton) {
      hide(actions);
    } // Custom class


    applyCustomClass(actions, params, &#039;actions&#039;); // Render confirm button

    renderButton(confirmButton, &#039;confirm&#039;, params); // render Cancel Button

    renderButton(cancelButton, &#039;cancel&#039;, params);

    if (params.buttonsStyling) {
      handleButtonsStyling(confirmButton, cancelButton, params);
    } else {
      removeClass([confirmButton, cancelButton], swalClasses.styled);
      confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = &#039;&#039;;
      cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = &#039;&#039;;
    }

    if (params.reverseButtons) {
      confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
    }
  };

  function handleButtonsStyling(confirmButton, cancelButton, params) {
    addClass([confirmButton, cancelButton], swalClasses.styled); // Buttons background colors

    if (params.confirmButtonColor) {
      confirmButton.style.backgroundColor = params.confirmButtonColor;
    }

    if (params.cancelButtonColor) {
      cancelButton.style.backgroundColor = params.cancelButtonColor;
    } // Loading state


    if (!isLoading()) {
      var confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue(&#039;background-color&#039;);
      confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;
      confirmButton.style.borderRightColor = confirmButtonBackgroundColor;
    }
  }

  function renderButton(button, buttonType, params) {
    toggle(button, params[&quot;show&quot;.concat(capitalizeFirstLetter(buttonType), &quot;Button&quot;)], &#039;inline-block&#039;);
    setInnerHtml(button, params[&quot;&quot;.concat(buttonType, &quot;ButtonText&quot;)]); // Set caption text

    button.setAttribute(&#039;aria-label&#039;, params[&quot;&quot;.concat(buttonType, &quot;ButtonAriaLabel&quot;)]); // ARIA label
    // Add buttons custom classes

    button.className = swalClasses[buttonType];
    applyCustomClass(button, params, &quot;&quot;.concat(buttonType, &quot;Button&quot;));
    addClass(button, params[&quot;&quot;.concat(buttonType, &quot;ButtonClass&quot;)]);
  }

  function handleBackdropParam(container, backdrop) {
    if (typeof backdrop === &#039;string&#039;) {
      container.style.background = backdrop;
    } else if (!backdrop) {
      addClass([document.documentElement, document.body], swalClasses[&#039;no-backdrop&#039;]);
    }
  }

  function handlePositionParam(container, position) {
    if (position in swalClasses) {
      addClass(container, swalClasses[position]);
    } else {
      warn(&#039;The &quot;position&quot; parameter is not valid, defaulting to &quot;center&quot;&#039;);
      addClass(container, swalClasses.center);
    }
  }

  function handleGrowParam(container, grow) {
    if (grow &amp;&amp; typeof grow === &#039;string&#039;) {
      var growClass = &quot;grow-&quot;.concat(grow);

      if (growClass in swalClasses) {
        addClass(container, swalClasses[growClass]);
      }
    }
  }

  var renderContainer = function renderContainer(instance, params) {
    var container = getContainer();

    if (!container) {
      return;
    }

    handleBackdropParam(container, params.backdrop);

    if (!params.backdrop &amp;&amp; params.allowOutsideClick) {
      warn(&#039;&quot;allowOutsideClick&quot; parameter requires `backdrop` parameter to be set to `true`&#039;);
    }

    handlePositionParam(container, params.position);
    handleGrowParam(container, params.grow); // Custom class

    applyCustomClass(container, params, &#039;container&#039;); // Set queue step attribute for getQueueStep() method

    var queueStep = document.body.getAttribute(&#039;data-swal2-queue-step&#039;);

    if (queueStep) {
      container.setAttribute(&#039;data-queue-step&#039;, queueStep);
      document.body.removeAttribute(&#039;data-swal2-queue-step&#039;);
    }
  };

  /**
   * This module containts `WeakMap`s for each effectively-&quot;private  property&quot; that a `Swal` has.
   * For example, to set the private property &quot;foo&quot; of `this` to &quot;bar&quot;, you can `privateProps.foo.set(this, &#039;bar&#039;)`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */
  var privateProps = {
    promise: new WeakMap(),
    innerParams: new WeakMap(),
    domCache: new WeakMap()
  };

  var inputTypes = [&#039;input&#039;, &#039;file&#039;, &#039;range&#039;, &#039;select&#039;, &#039;radio&#039;, &#039;checkbox&#039;, &#039;textarea&#039;];
  var renderInput = function renderInput(instance, params) {
    var content = getContent();
    var innerParams = privateProps.innerParams.get(instance);
    var rerender = !innerParams || params.input !== innerParams.input;
    inputTypes.forEach(function (inputType) {
      var inputClass = swalClasses[inputType];
      var inputContainer = getChildByClass(content, inputClass); // set attributes

      setAttributes(inputType, params.inputAttributes); // set class

      inputContainer.className = inputClass;

      if (rerender) {
        hide(inputContainer);
      }
    });

    if (params.input) {
      if (rerender) {
        showInput(params);
      } // set custom class


      setCustomClass(params);
    }
  };

  var showInput = function showInput(params) {
    if (!renderInputType[params.input]) {
      return error(&quot;Unexpected type of input! Expected \&quot;text\&quot;, \&quot;email\&quot;, \&quot;password\&quot;, \&quot;number\&quot;, \&quot;tel\&quot;, \&quot;select\&quot;, \&quot;radio\&quot;, \&quot;checkbox\&quot;, \&quot;textarea\&quot;, \&quot;file\&quot; or \&quot;url\&quot;, got \&quot;&quot;.concat(params.input, &quot;\&quot;&quot;));
    }

    var inputContainer = getInputContainer(params.input);
    var input = renderInputType[params.input](inputContainer, params);
    show(input); // input autofocus

    setTimeout(function () {
      focusInput(input);
    });
  };

  var removeAttributes = function removeAttributes(input) {
    for (var i = 0; i &lt; input.attributes.length; i++) {
      var attrName = input.attributes[i].name;

      if (!([&#039;type&#039;, &#039;value&#039;, &#039;style&#039;].indexOf(attrName) !== -1)) {
        input.removeAttribute(attrName);
      }
    }
  };

  var setAttributes = function setAttributes(inputType, inputAttributes) {
    var input = getInput(getContent(), inputType);

    if (!input) {
      return;
    }

    removeAttributes(input);

    for (var attr in inputAttributes) {
      // Do not set a placeholder for &lt;input type=&quot;range&quot;&gt;
      // it&#039;ll crash Edge, #1298
      if (inputType === &#039;range&#039; &amp;&amp; attr === &#039;placeholder&#039;) {
        continue;
      }

      input.setAttribute(attr, inputAttributes[attr]);
    }
  };

  var setCustomClass = function setCustomClass(params) {
    var inputContainer = getInputContainer(params.input);

    if (params.customClass) {
      addClass(inputContainer, params.customClass.input);
    }
  };

  var setInputPlaceholder = function setInputPlaceholder(input, params) {
    if (!input.placeholder || params.inputPlaceholder) {
      input.placeholder = params.inputPlaceholder;
    }
  };

  var getInputContainer = function getInputContainer(inputType) {
    var inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
    return getChildByClass(getContent(), inputClass);
  };

  var renderInputType = {};

  renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = function (input, params) {
    if (typeof params.inputValue === &#039;string&#039; || typeof params.inputValue === &#039;number&#039;) {
      input.value = params.inputValue;
    } else if (!isPromise(params.inputValue)) {
      warn(&quot;Unexpected type of inputValue! Expected \&quot;string\&quot;, \&quot;number\&quot; or \&quot;Promise\&quot;, got \&quot;&quot;.concat(_typeof(params.inputValue), &quot;\&quot;&quot;));
    }

    setInputPlaceholder(input, params);
    input.type = params.input;
    return input;
  };

  renderInputType.file = function (input, params) {
    setInputPlaceholder(input, params);
    return input;
  };

  renderInputType.range = function (range, params) {
    var rangeInput = range.querySelector(&#039;input&#039;);
    var rangeOutput = range.querySelector(&#039;output&#039;);
    rangeInput.value = params.inputValue;
    rangeInput.type = params.input;
    rangeOutput.value = params.inputValue;
    return range;
  };

  renderInputType.select = function (select, params) {
    select.textContent = &#039;&#039;;

    if (params.inputPlaceholder) {
      var placeholder = document.createElement(&#039;option&#039;);
      setInnerHtml(placeholder, params.inputPlaceholder);
      placeholder.value = &#039;&#039;;
      placeholder.disabled = true;
      placeholder.selected = true;
      select.appendChild(placeholder);
    }

    return select;
  };

  renderInputType.radio = function (radio) {
    radio.textContent = &#039;&#039;;
    return radio;
  };

  renderInputType.checkbox = function (checkboxContainer, params) {
    var checkbox = getInput(getContent(), &#039;checkbox&#039;);
    checkbox.value = 1;
    checkbox.id = swalClasses.checkbox;
    checkbox.checked = Boolean(params.inputValue);
    var label = checkboxContainer.querySelector(&#039;span&#039;);
    setInnerHtml(label, params.inputPlaceholder);
    return checkboxContainer;
  };

  renderInputType.textarea = function (textarea, params) {
    textarea.value = params.inputValue;
    setInputPlaceholder(textarea, params);

    if (&#039;MutationObserver&#039; in window) {
      // #1699
      var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
      var popupPadding = parseInt(window.getComputedStyle(getPopup()).paddingLeft) + parseInt(window.getComputedStyle(getPopup()).paddingRight);

      var outputsize = function outputsize() {
        var contentWidth = textarea.offsetWidth + popupPadding;

        if (contentWidth &gt; initialPopupWidth) {
          getPopup().style.width = &quot;&quot;.concat(contentWidth, &quot;px&quot;);
        } else {
          getPopup().style.width = null;
        }
      };

      new MutationObserver(outputsize).observe(textarea, {
        attributes: true,
        attributeFilter: [&#039;style&#039;]
      });
    }

    return textarea;
  };

  var renderContent = function renderContent(instance, params) {
    var content = getContent().querySelector(&quot;#&quot;.concat(swalClasses.content)); // Content as HTML

    if (params.html) {
      parseHtmlToContainer(params.html, content);
      show(content, &#039;block&#039;); // Content as plain text
    } else if (params.text) {
      content.textContent = params.text;
      show(content, &#039;block&#039;); // No content
    } else {
      hide(content);
    }

    renderInput(instance, params); // Custom class

    applyCustomClass(getContent(), params, &#039;content&#039;);
  };

  var renderFooter = function renderFooter(instance, params) {
    var footer = getFooter();
    toggle(footer, params.footer);

    if (params.footer) {
      parseHtmlToContainer(params.footer, footer);
    } // Custom class


    applyCustomClass(footer, params, &#039;footer&#039;);
  };

  var renderCloseButton = function renderCloseButton(instance, params) {
    var closeButton = getCloseButton();
    setInnerHtml(closeButton, params.closeButtonHtml); // Custom class

    applyCustomClass(closeButton, params, &#039;closeButton&#039;);
    toggle(closeButton, params.showCloseButton);
    closeButton.setAttribute(&#039;aria-label&#039;, params.closeButtonAriaLabel);
  };

  var renderIcon = function renderIcon(instance, params) {
    var innerParams = privateProps.innerParams.get(instance); // if the give icon already rendered, apply the custom class without re-rendering the icon

    if (innerParams &amp;&amp; params.icon === innerParams.icon &amp;&amp; getIcon()) {
      applyCustomClass(getIcon(), params, &#039;icon&#039;);
      return;
    }

    hideAllIcons();

    if (!params.icon) {
      return;
    }

    if (Object.keys(iconTypes).indexOf(params.icon) !== -1) {
      var icon = elementBySelector(&quot;.&quot;.concat(swalClasses.icon, &quot;.&quot;).concat(iconTypes[params.icon]));
      show(icon); // Custom or default content

      setContent(icon, params);
      adjustSuccessIconBackgoundColor(); // Custom class

      applyCustomClass(icon, params, &#039;icon&#039;); // Animate icon

      addClass(icon, params.showClass.icon);
    } else {
      error(&quot;Unknown icon! Expected \&quot;success\&quot;, \&quot;error\&quot;, \&quot;warning\&quot;, \&quot;info\&quot; or \&quot;question\&quot;, got \&quot;&quot;.concat(params.icon, &quot;\&quot;&quot;));
    }
  };

  var hideAllIcons = function hideAllIcons() {
    var icons = getIcons();

    for (var i = 0; i &lt; icons.length; i++) {
      hide(icons[i]);
    }
  }; // Adjust success icon background color to match the popup background color


  var adjustSuccessIconBackgoundColor = function adjustSuccessIconBackgoundColor() {
    var popup = getPopup();
    var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue(&#039;background-color&#039;);
    var successIconParts = popup.querySelectorAll(&#039;[class^=swal2-success-circular-line], .swal2-success-fix&#039;);

    for (var i = 0; i &lt; successIconParts.length; i++) {
      successIconParts[i].style.backgroundColor = popupBackgroundColor;
    }
  };

  var setContent = function setContent(icon, params) {
    icon.textContent = &#039;&#039;;

    if (params.iconHtml) {
      setInnerHtml(icon, iconContent(params.iconHtml));
    } else if (params.icon === &#039;success&#039;) {
      setInnerHtml(icon, &quot;\n      &lt;div class=\&quot;swal2-success-circular-line-left\&quot;&gt;&lt;/div&gt;\n      &lt;span class=\&quot;swal2-success-line-tip\&quot;&gt;&lt;/span&gt; &lt;span class=\&quot;swal2-success-line-long\&quot;&gt;&lt;/span&gt;\n      &lt;div class=\&quot;swal2-success-ring\&quot;&gt;&lt;/div&gt; &lt;div class=\&quot;swal2-success-fix\&quot;&gt;&lt;/div&gt;\n      &lt;div class=\&quot;swal2-success-circular-line-right\&quot;&gt;&lt;/div&gt;\n    &quot;);
    } else if (params.icon === &#039;error&#039;) {
      setInnerHtml(icon, &quot;\n      &lt;span class=\&quot;swal2-x-mark\&quot;&gt;\n        &lt;span class=\&quot;swal2-x-mark-line-left\&quot;&gt;&lt;/span&gt;\n        &lt;span class=\&quot;swal2-x-mark-line-right\&quot;&gt;&lt;/span&gt;\n      &lt;/span&gt;\n    &quot;);
    } else {
      var defaultIconHtml = {
        question: &#039;?&#039;,
        warning: &#039;!&#039;,
        info: &#039;i&#039;
      };
      setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));
    }
  };

  var iconContent = function iconContent(content) {
    return &quot;&lt;div class=\&quot;&quot;.concat(swalClasses[&#039;icon-content&#039;], &quot;\&quot;&gt;&quot;).concat(content, &quot;&lt;/div&gt;&quot;);
  };

  var renderImage = function renderImage(instance, params) {
    var image = getImage();

    if (!params.imageUrl) {
      return hide(image);
    }

    show(image, &#039;&#039;); // Src, alt

    image.setAttribute(&#039;src&#039;, params.imageUrl);
    image.setAttribute(&#039;alt&#039;, params.imageAlt); // Width, height

    applyNumericalStyle(image, &#039;width&#039;, params.imageWidth);
    applyNumericalStyle(image, &#039;height&#039;, params.imageHeight); // Class

    image.className = swalClasses.image;
    applyCustomClass(image, params, &#039;image&#039;);
  };

  var currentSteps = [];
  /*
   * Global function for chaining sweetAlert popups
   */

  var queue = function queue(steps) {
    var Swal = this;
    currentSteps = steps;

    var resetAndResolve = function resetAndResolve(resolve, value) {
      currentSteps = [];
      resolve(value);
    };

    var queueResult = [];
    return new Promise(function (resolve) {
      (function step(i, callback) {
        if (i &lt; currentSteps.length) {
          document.body.setAttribute(&#039;data-swal2-queue-step&#039;, i);
          Swal.fire(currentSteps[i]).then(function (result) {
            if (typeof result.value !== &#039;undefined&#039;) {
              queueResult.push(result.value);
              step(i + 1, callback);
            } else {
              resetAndResolve(resolve, {
                dismiss: result.dismiss
              });
            }
          });
        } else {
          resetAndResolve(resolve, {
            value: queueResult
          });
        }
      })(0);
    });
  };
  /*
   * Global function for getting the index of current popup in queue
   */

  var getQueueStep = function getQueueStep() {
    return getContainer() &amp;&amp; getContainer().getAttribute(&#039;data-queue-step&#039;);
  };
  /*
   * Global function for inserting a popup to the queue
   */

  var insertQueueStep = function insertQueueStep(step, index) {
    if (index &amp;&amp; index &lt; currentSteps.length) {
      return currentSteps.splice(index, 0, step);
    }

    return currentSteps.push(step);
  };
  /*
   * Global function for deleting a popup from the queue
   */

  var deleteQueueStep = function deleteQueueStep(index) {
    if (typeof currentSteps[index] !== &#039;undefined&#039;) {
      currentSteps.splice(index, 1);
    }
  };

  var createStepElement = function createStepElement(step) {
    var stepEl = document.createElement(&#039;li&#039;);
    addClass(stepEl, swalClasses[&#039;progress-step&#039;]);
    setInnerHtml(stepEl, step);
    return stepEl;
  };

  var createLineElement = function createLineElement(params) {
    var lineEl = document.createElement(&#039;li&#039;);
    addClass(lineEl, swalClasses[&#039;progress-step-line&#039;]);

    if (params.progressStepsDistance) {
      lineEl.style.width = params.progressStepsDistance;
    }

    return lineEl;
  };

  var renderProgressSteps = function renderProgressSteps(instance, params) {
    var progressStepsContainer = getProgressSteps();

    if (!params.progressSteps || params.progressSteps.length === 0) {
      return hide(progressStepsContainer);
    }

    show(progressStepsContainer);
    progressStepsContainer.textContent = &#039;&#039;;
    var currentProgressStep = parseInt(params.currentProgressStep === undefined ? getQueueStep() : params.currentProgressStep);

    if (currentProgressStep &gt;= params.progressSteps.length) {
      warn(&#039;Invalid currentProgressStep parameter, it should be less than progressSteps.length &#039; + &#039;(currentProgressStep like JS arrays starts from 0)&#039;);
    }

    params.progressSteps.forEach(function (step, index) {
      var stepEl = createStepElement(step);
      progressStepsContainer.appendChild(stepEl);

      if (index === currentProgressStep) {
        addClass(stepEl, swalClasses[&#039;active-progress-step&#039;]);
      }

      if (index !== params.progressSteps.length - 1) {
        var lineEl = createLineElement(params);
        progressStepsContainer.appendChild(lineEl);
      }
    });
  };

  var renderTitle = function renderTitle(instance, params) {
    var title = getTitle();
    toggle(title, params.title || params.titleText);

    if (params.title) {
      parseHtmlToContainer(params.title, title);
    }

    if (params.titleText) {
      title.innerText = params.titleText;
    } // Custom class


    applyCustomClass(title, params, &#039;title&#039;);
  };

  var renderHeader = function renderHeader(instance, params) {
    var header = getHeader(); // Custom class

    applyCustomClass(header, params, &#039;header&#039;); // Progress steps

    renderProgressSteps(instance, params); // Icon

    renderIcon(instance, params); // Image

    renderImage(instance, params); // Title

    renderTitle(instance, params); // Close button

    renderCloseButton(instance, params);
  };

  var renderPopup = function renderPopup(instance, params) {
    var popup = getPopup(); // Width

    applyNumericalStyle(popup, &#039;width&#039;, params.width); // Padding

    applyNumericalStyle(popup, &#039;padding&#039;, params.padding); // Background

    if (params.background) {
      popup.style.background = params.background;
    } // Classes


    addClasses(popup, params);
  };

  var addClasses = function addClasses(popup, params) {
    // Default Class + showClass when updating Swal.update({})
    popup.className = &quot;&quot;.concat(swalClasses.popup, &quot; &quot;).concat(isVisible(popup) ? params.showClass.popup : &#039;&#039;);

    if (params.toast) {
      addClass([document.documentElement, document.body], swalClasses[&#039;toast-shown&#039;]);
      addClass(popup, swalClasses.toast);
    } else {
      addClass(popup, swalClasses.modal);
    } // Custom class


    applyCustomClass(popup, params, &#039;popup&#039;);

    if (typeof params.customClass === &#039;string&#039;) {
      addClass(popup, params.customClass);
    } // Icon class (#1842)


    if (params.icon) {
      addClass(popup, swalClasses[&quot;icon-&quot;.concat(params.icon)]);
    }
  };

  var render = function render(instance, params) {
    renderPopup(instance, params);
    renderContainer(instance, params);
    renderHeader(instance, params);
    renderContent(instance, params);
    renderActions(instance, params);
    renderFooter(instance, params);

    if (typeof params.onRender === &#039;function&#039;) {
      params.onRender(getPopup());
    }
  };

  /*
   * Global function to determine if SweetAlert2 popup is shown
   */

  var isVisible$1 = function isVisible$$1() {
    return isVisible(getPopup());
  };
  /*
   * Global function to click &#039;Confirm&#039; button
   */

  var clickConfirm = function clickConfirm() {
    return getConfirmButton() &amp;&amp; getConfirmButton().click();
  };
  /*
   * Global function to click &#039;Cancel&#039; button
   */

  var clickCancel = function clickCancel() {
    return getCancelButton() &amp;&amp; getCancelButton().click();
  };

  function fire() {
    var Swal = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key &lt; _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _construct(Swal, args);
  }

  /**
   * Returns an extended version of `Swal` containing `params` as defaults.
   * Useful for reusing Swal configuration.
   *
   * For example:
   *
   * Before:
   * const textPromptOptions = { input: &#039;text&#039;, showCancelButton: true }
   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: &#039;What is your first name?&#039; })
   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: &#039;What is your last name?&#039; })
   *
   * After:
   * const TextPrompt = Swal.mixin({ input: &#039;text&#039;, showCancelButton: true })
   * const {value: firstName} = await TextPrompt(&#039;What is your first name?&#039;)
   * const {value: lastName} = await TextPrompt(&#039;What is your last name?&#039;)
   *
   * @param mixinParams
   */
  function mixin(mixinParams) {
    var MixinSwal = /*#__PURE__*/function (_this) {
      _inherits(MixinSwal, _this);

      var _super = _createSuper(MixinSwal);

      function MixinSwal() {
        _classCallCheck(this, MixinSwal);

        return _super.apply(this, arguments);
      }

      _createClass(MixinSwal, [{
        key: &quot;_main&quot;,
        value: function _main(params) {
          return _get(_getPrototypeOf(MixinSwal.prototype), &quot;_main&quot;, this).call(this, _extends({}, mixinParams, params));
        }
      }]);

      return MixinSwal;
    }(this);

    return MixinSwal;
  }

  /**
   * Show spinner instead of Confirm button
   */

  var showLoading = function showLoading() {
    var popup = getPopup();

    if (!popup) {
      Swal.fire();
    }

    popup = getPopup();
    var actions = getActions();
    var confirmButton = getConfirmButton();
    show(actions);
    show(confirmButton, &#039;inline-block&#039;);
    addClass([popup, actions], swalClasses.loading);
    confirmButton.disabled = true;
    popup.setAttribute(&#039;data-loading&#039;, true);
    popup.setAttribute(&#039;aria-busy&#039;, true);
    popup.focus();
  };

  var RESTORE_FOCUS_TIMEOUT = 100;

  var globalState = {};

  var focusPreviousActiveElement = function focusPreviousActiveElement() {
    if (globalState.previousActiveElement &amp;&amp; globalState.previousActiveElement.focus) {
      globalState.previousActiveElement.focus();
      globalState.previousActiveElement = null;
    } else if (document.body) {
      document.body.focus();
    }
  }; // Restore previous active (focused) element


  var restoreActiveElement = function restoreActiveElement() {
    return new Promise(function (resolve) {
      var x = window.scrollX;
      var y = window.scrollY;
      globalState.restoreFocusTimeout = setTimeout(function () {
        focusPreviousActiveElement();
        resolve();
      }, RESTORE_FOCUS_TIMEOUT); // issues/900

      /* istanbul ignore if */

      if (typeof x !== &#039;undefined&#039; &amp;&amp; typeof y !== &#039;undefined&#039;) {
        // IE doesn&#039;t have scrollX/scrollY support
        window.scrollTo(x, y);
      }
    });
  };

  /**
   * If `timer` parameter is set, returns number of milliseconds of timer remained.
   * Otherwise, returns undefined.
   */

  var getTimerLeft = function getTimerLeft() {
    return globalState.timeout &amp;&amp; globalState.timeout.getTimerLeft();
  };
  /**
   * Stop timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn&#039;t set, returns undefined.
   */

  var stopTimer = function stopTimer() {
    if (globalState.timeout) {
      stopTimerProgressBar();
      return globalState.timeout.stop();
    }
  };
  /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn&#039;t set, returns undefined.
   */

  var resumeTimer = function resumeTimer() {
    if (globalState.timeout) {
      var remaining = globalState.timeout.start();
      animateTimerProgressBar(remaining);
      return remaining;
    }
  };
  /**
   * Resume timer. Returns number of milliseconds of timer remained.
   * If `timer` parameter isn&#039;t set, returns undefined.
   */

  var toggleTimer = function toggleTimer() {
    var timer = globalState.timeout;
    return timer &amp;&amp; (timer.running ? stopTimer() : resumeTimer());
  };
  /**
   * Increase timer. Returns number of milliseconds of an updated timer.
   * If `timer` parameter isn&#039;t set, returns undefined.
   */

  var increaseTimer = function increaseTimer(n) {
    if (globalState.timeout) {
      var remaining = globalState.timeout.increase(n);
      animateTimerProgressBar(remaining, true);
      return remaining;
    }
  };
  /**
   * Check if timer is running. Returns true if timer is running
   * or false if timer is paused or stopped.
   * If `timer` parameter isn&#039;t set, returns undefined
   */

  var isTimerRunning = function isTimerRunning() {
    return globalState.timeout &amp;&amp; globalState.timeout.isRunning();
  };

  var defaultParams = {
    title: &#039;&#039;,
    titleText: &#039;&#039;,
    text: &#039;&#039;,
    html: &#039;&#039;,
    footer: &#039;&#039;,
    icon: undefined,
    iconHtml: undefined,
    toast: false,
    animation: true,
    showClass: {
      popup: &#039;swal2-show&#039;,
      backdrop: &#039;swal2-backdrop-show&#039;,
      icon: &#039;swal2-icon-show&#039;
    },
    hideClass: {
      popup: &#039;swal2-hide&#039;,
      backdrop: &#039;swal2-backdrop-hide&#039;,
      icon: &#039;swal2-icon-hide&#039;
    },
    customClass: undefined,
    target: &#039;body&#039;,
    backdrop: true,
    heightAuto: true,
    allowOutsideClick: true,
    allowEscapeKey: true,
    allowEnterKey: true,
    stopKeydownPropagation: true,
    keydownListenerCapture: false,
    showConfirmButton: true,
    showCancelButton: false,
    preConfirm: undefined,
    confirmButtonText: &#039;OK&#039;,
    confirmButtonAriaLabel: &#039;&#039;,
    confirmButtonColor: undefined,
    cancelButtonText: &#039;Cancel&#039;,
    cancelButtonAriaLabel: &#039;&#039;,
    cancelButtonColor: undefined,
    buttonsStyling: true,
    reverseButtons: false,
    focusConfirm: true,
    focusCancel: false,
    showCloseButton: false,
    closeButtonHtml: &#039;&amp;times;&#039;,
    closeButtonAriaLabel: &#039;Close this dialog&#039;,
    showLoaderOnConfirm: false,
    imageUrl: undefined,
    imageWidth: undefined,
    imageHeight: undefined,
    imageAlt: &#039;&#039;,
    timer: undefined,
    timerProgressBar: false,
    width: undefined,
    padding: undefined,
    background: undefined,
    input: undefined,
    inputPlaceholder: &#039;&#039;,
    inputValue: &#039;&#039;,
    inputOptions: {},
    inputAutoTrim: true,
    inputAttributes: {},
    inputValidator: undefined,
    validationMessage: undefined,
    grow: false,
    position: &#039;center&#039;,
    progressSteps: [],
    currentProgressStep: undefined,
    progressStepsDistance: undefined,
    onBeforeOpen: undefined,
    onOpen: undefined,
    onRender: undefined,
    onClose: undefined,
    onAfterClose: undefined,
    onDestroy: undefined,
    scrollbarPadding: true
  };
  var updatableParams = [&#039;allowEscapeKey&#039;, &#039;allowOutsideClick&#039;, &#039;buttonsStyling&#039;, &#039;cancelButtonAriaLabel&#039;, &#039;cancelButtonColor&#039;, &#039;cancelButtonText&#039;, &#039;closeButtonAriaLabel&#039;, &#039;closeButtonHtml&#039;, &#039;confirmButtonAriaLabel&#039;, &#039;confirmButtonColor&#039;, &#039;confirmButtonText&#039;, &#039;currentProgressStep&#039;, &#039;customClass&#039;, &#039;footer&#039;, &#039;hideClass&#039;, &#039;html&#039;, &#039;icon&#039;, &#039;imageAlt&#039;, &#039;imageHeight&#039;, &#039;imageUrl&#039;, &#039;imageWidth&#039;, &#039;onAfterClose&#039;, &#039;onClose&#039;, &#039;onDestroy&#039;, &#039;progressSteps&#039;, &#039;reverseButtons&#039;, &#039;showCancelButton&#039;, &#039;showCloseButton&#039;, &#039;showConfirmButton&#039;, &#039;text&#039;, &#039;title&#039;, &#039;titleText&#039;];
  var deprecatedParams = {
    animation: &#039;showClass&quot; and &quot;hideClass&#039;
  };
  var toastIncompatibleParams = [&#039;allowOutsideClick&#039;, &#039;allowEnterKey&#039;, &#039;backdrop&#039;, &#039;focusConfirm&#039;, &#039;focusCancel&#039;, &#039;heightAuto&#039;, &#039;keydownListenerCapture&#039;];
  /**
   * Is valid parameter
   * @param {String} paramName
   */

  var isValidParameter = function isValidParameter(paramName) {
    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
  };
  /**
   * Is valid parameter for Swal.update() method
   * @param {String} paramName
   */

  var isUpdatableParameter = function isUpdatableParameter(paramName) {
    return updatableParams.indexOf(paramName) !== -1;
  };
  /**
   * Is deprecated parameter
   * @param {String} paramName
   */

  var isDeprecatedParameter = function isDeprecatedParameter(paramName) {
    return deprecatedParams[paramName];
  };

  var checkIfParamIsValid = function checkIfParamIsValid(param) {
    if (!isValidParameter(param)) {
      warn(&quot;Unknown parameter \&quot;&quot;.concat(param, &quot;\&quot;&quot;));
    }
  };

  var checkIfToastParamIsValid = function checkIfToastParamIsValid(param) {
    if (toastIncompatibleParams.indexOf(param) !== -1) {
      warn(&quot;The parameter \&quot;&quot;.concat(param, &quot;\&quot; is incompatible with toasts&quot;));
    }
  };

  var checkIfParamIsDeprecated = function checkIfParamIsDeprecated(param) {
    if (isDeprecatedParameter(param)) {
      warnAboutDepreation(param, isDeprecatedParameter(param));
    }
  };
  /**
   * Show relevant warnings for given params
   *
   * @param params
   */


  var showWarningsForParams = function showWarningsForParams(params) {
    for (var param in params) {
      checkIfParamIsValid(param);

      if (params.toast) {
        checkIfToastParamIsValid(param);
      }

      checkIfParamIsDeprecated(param);
    }
  };



  var staticMethods = /*#__PURE__*/Object.freeze({
    isValidParameter: isValidParameter,
    isUpdatableParameter: isUpdatableParameter,
    isDeprecatedParameter: isDeprecatedParameter,
    argsToParams: argsToParams,
    isVisible: isVisible$1,
    clickConfirm: clickConfirm,
    clickCancel: clickCancel,
    getContainer: getContainer,
    getPopup: getPopup,
    getTitle: getTitle,
    getContent: getContent,
    getHtmlContainer: getHtmlContainer,
    getImage: getImage,
    getIcon: getIcon,
    getIcons: getIcons,
    getCloseButton: getCloseButton,
    getActions: getActions,
    getConfirmButton: getConfirmButton,
    getCancelButton: getCancelButton,
    getHeader: getHeader,
    getFooter: getFooter,
    getTimerProgressBar: getTimerProgressBar,
    getFocusableElements: getFocusableElements,
    getValidationMessage: getValidationMessage,
    isLoading: isLoading,
    fire: fire,
    mixin: mixin,
    queue: queue,
    getQueueStep: getQueueStep,
    insertQueueStep: insertQueueStep,
    deleteQueueStep: deleteQueueStep,
    showLoading: showLoading,
    enableLoading: showLoading,
    getTimerLeft: getTimerLeft,
    stopTimer: stopTimer,
    resumeTimer: resumeTimer,
    toggleTimer: toggleTimer,
    increaseTimer: increaseTimer,
    isTimerRunning: isTimerRunning
  });

  /**
   * Enables buttons and hide loader.
   */

  function hideLoading() {
    // do nothing if popup is closed
    var innerParams = privateProps.innerParams.get(this);

    if (!innerParams) {
      return;
    }

    var domCache = privateProps.domCache.get(this);

    if (!innerParams.showConfirmButton) {
      hide(domCache.confirmButton);

      if (!innerParams.showCancelButton) {
        hide(domCache.actions);
      }
    }

    removeClass([domCache.popup, domCache.actions], swalClasses.loading);
    domCache.popup.removeAttribute(&#039;aria-busy&#039;);
    domCache.popup.removeAttribute(&#039;data-loading&#039;);
    domCache.confirmButton.disabled = false;
    domCache.cancelButton.disabled = false;
  }

  function getInput$1(instance) {
    var innerParams = privateProps.innerParams.get(instance || this);
    var domCache = privateProps.domCache.get(instance || this);

    if (!domCache) {
      return null;
    }

    return getInput(domCache.content, innerParams.input);
  }

  var fixScrollbar = function fixScrollbar() {
    // for queues, do not do this more than once
    if (states.previousBodyPadding !== null) {
      return;
    } // if the body has overflow


    if (document.body.scrollHeight &gt; window.innerHeight) {
      // add padding so the content doesn&#039;t shift after removal of scrollbar
      states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue(&#039;padding-right&#039;));
      document.body.style.paddingRight = &quot;&quot;.concat(states.previousBodyPadding + measureScrollbar(), &quot;px&quot;);
    }
  };
  var undoScrollbar = function undoScrollbar() {
    if (states.previousBodyPadding !== null) {
      document.body.style.paddingRight = &quot;&quot;.concat(states.previousBodyPadding, &quot;px&quot;);
      states.previousBodyPadding = null;
    }
  };

  /* istanbul ignore file */

  var iOSfix = function iOSfix() {
    var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) &amp;&amp; !window.MSStream || navigator.platform === &#039;MacIntel&#039; &amp;&amp; navigator.maxTouchPoints &gt; 1;

    if (iOS &amp;&amp; !hasClass(document.body, swalClasses.iosfix)) {
      var offset = document.body.scrollTop;
      document.body.style.top = &quot;&quot;.concat(offset * -1, &quot;px&quot;);
      addClass(document.body, swalClasses.iosfix);
      lockBodyScroll();
      addBottomPaddingForTallPopups(); // #1948
    }
  };

  var addBottomPaddingForTallPopups = function addBottomPaddingForTallPopups() {
    var safari = !navigator.userAgent.match(/(CriOS|FxiOS|EdgiOS|YaBrowser|UCBrowser)/i);

    if (safari) {
      var bottomPanelHeight = 44;

      if (getPopup().scrollHeight &gt; window.innerHeight - bottomPanelHeight) {
        getContainer().style.paddingBottom = &quot;&quot;.concat(bottomPanelHeight, &quot;px&quot;);
      }
    }
  };

  var lockBodyScroll = function lockBodyScroll() {
    // #1246
    var container = getContainer();
    var preventTouchMove;

    container.ontouchstart = function (e) {
      preventTouchMove = shouldPreventTouchMove(e.target);
    };

    container.ontouchmove = function (e) {
      if (preventTouchMove) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
  };

  var shouldPreventTouchMove = function shouldPreventTouchMove(target) {
    var container = getContainer();

    if (target === container) {
      return true;
    }

    if (!isScrollable(container) &amp;&amp; target.tagName !== &#039;INPUT&#039; &amp;&amp; // #1603
    !(isScrollable(getContent()) &amp;&amp; // #1944
    getContent().contains(target))) {
      return true;
    }

    return false;
  };

  var undoIOSfix = function undoIOSfix() {
    if (hasClass(document.body, swalClasses.iosfix)) {
      var offset = parseInt(document.body.style.top, 10);
      removeClass(document.body, swalClasses.iosfix);
      document.body.style.top = &#039;&#039;;
      document.body.scrollTop = offset * -1;
    }
  };

  /* istanbul ignore file */

  var isIE11 = function isIE11() {
    return !!window.MSInputMethodContext &amp;&amp; !!document.documentMode;
  }; // Fix IE11 centering sweetalert2/issues/933


  var fixVerticalPositionIE = function fixVerticalPositionIE() {
    var container = getContainer();
    var popup = getPopup();
    container.style.removeProperty(&#039;align-items&#039;);

    if (popup.offsetTop &lt; 0) {
      container.style.alignItems = &#039;flex-start&#039;;
    }
  };

  var IEfix = function IEfix() {
    if (typeof window !== &#039;undefined&#039; &amp;&amp; isIE11()) {
      fixVerticalPositionIE();
      window.addEventListener(&#039;resize&#039;, fixVerticalPositionIE);
    }
  };
  var undoIEfix = function undoIEfix() {
    if (typeof window !== &#039;undefined&#039; &amp;&amp; isIE11()) {
      window.removeEventListener(&#039;resize&#039;, fixVerticalPositionIE);
    }
  };

  // Adding aria-hidden=&quot;true&quot; to elements outside of the active modal dialog ensures that
  // elements not within the active modal dialog will not be surfaced if a user opens a screen
  // reader’s list of elements (headings, form controls, landmarks, etc.) in the document.

  var setAriaHidden = function setAriaHidden() {
    var bodyChildren = toArray(document.body.children);
    bodyChildren.forEach(function (el) {
      if (el === getContainer() || contains(el, getContainer())) {
        return;
      }

      if (el.hasAttribute(&#039;aria-hidden&#039;)) {
        el.setAttribute(&#039;data-previous-aria-hidden&#039;, el.getAttribute(&#039;aria-hidden&#039;));
      }

      el.setAttribute(&#039;aria-hidden&#039;, &#039;true&#039;);
    });
  };
  var unsetAriaHidden = function unsetAriaHidden() {
    var bodyChildren = toArray(document.body.children);
    bodyChildren.forEach(function (el) {
      if (el.hasAttribute(&#039;data-previous-aria-hidden&#039;)) {
        el.setAttribute(&#039;aria-hidden&#039;, el.getAttribute(&#039;data-previous-aria-hidden&#039;));
        el.removeAttribute(&#039;data-previous-aria-hidden&#039;);
      } else {
        el.removeAttribute(&#039;aria-hidden&#039;);
      }
    });
  };

  /**
   * This module containts `WeakMap`s for each effectively-&quot;private  property&quot; that a `Swal` has.
   * For example, to set the private property &quot;foo&quot; of `this` to &quot;bar&quot;, you can `privateProps.foo.set(this, &#039;bar&#039;)`
   * This is the approach that Babel will probably take to implement private methods/fields
   *   https://github.com/tc39/proposal-private-methods
   *   https://github.com/babel/babel/pull/7555
   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*
   *   then we can use that language feature.
   */
  var privateMethods = {
    swalPromiseResolve: new WeakMap()
  };

  /*
   * Instance method to close sweetAlert
   */

  function removePopupAndResetState(instance, container, isToast$$1, onAfterClose) {
    if (isToast$$1) {
      triggerOnAfterCloseAndDispose(instance, onAfterClose);
    } else {
      restoreActiveElement().then(function () {
        return triggerOnAfterCloseAndDispose(instance, onAfterClose);
      });
      globalState.keydownTarget.removeEventListener(&#039;keydown&#039;, globalState.keydownHandler, {
        capture: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = false;
    }

    if (container.parentNode &amp;&amp; !document.body.getAttribute(&#039;data-swal2-queue-step&#039;)) {
      container.parentNode.removeChild(container);
    }

    if (isModal()) {
      undoScrollbar();
      undoIOSfix();
      undoIEfix();
      unsetAriaHidden();
    }

    removeBodyClasses();
  }

  function removeBodyClasses() {
    removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses[&#039;height-auto&#039;], swalClasses[&#039;no-backdrop&#039;], swalClasses[&#039;toast-shown&#039;], swalClasses[&#039;toast-column&#039;]]);
  }

  function close(resolveValue) {
    var popup = getPopup();

    if (!popup) {
      return;
    }

    var innerParams = privateProps.innerParams.get(this);

    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
      return;
    }

    var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
    removeClass(popup, innerParams.showClass.popup);
    addClass(popup, innerParams.hideClass.popup);
    var backdrop = getContainer();
    removeClass(backdrop, innerParams.showClass.backdrop);
    addClass(backdrop, innerParams.hideClass.backdrop);
    handlePopupAnimation(this, popup, innerParams);

    if (typeof resolveValue !== &#039;undefined&#039;) {
      resolveValue.isDismissed = typeof resolveValue.dismiss !== &#039;undefined&#039;;
      resolveValue.isConfirmed = typeof resolveValue.dismiss === &#039;undefined&#039;;
    } else {
      resolveValue = {
        isDismissed: true,
        isConfirmed: false
      };
    } // Resolve Swal promise


    swalPromiseResolve(resolveValue || {});
  }

  var handlePopupAnimation = function handlePopupAnimation(instance, popup, innerParams) {
    var container = getContainer(); // If animation is supported, animate

    var animationIsSupported = animationEndEvent &amp;&amp; hasCssAnimation(popup);
    var onClose = innerParams.onClose,
        onAfterClose = innerParams.onAfterClose;

    if (onClose !== null &amp;&amp; typeof onClose === &#039;function&#039;) {
      onClose(popup);
    }

    if (animationIsSupported) {
      animatePopup(instance, popup, container, onAfterClose);
    } else {
      // Otherwise, remove immediately
      removePopupAndResetState(instance, container, isToast(), onAfterClose);
    }
  };

  var animatePopup = function animatePopup(instance, popup, container, onAfterClose) {
    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, isToast(), onAfterClose);
    popup.addEventListener(animationEndEvent, function (e) {
      if (e.target === popup) {
        globalState.swalCloseEventFinishedCallback();
        delete globalState.swalCloseEventFinishedCallback;
      }
    });
  };

  var triggerOnAfterCloseAndDispose = function triggerOnAfterCloseAndDispose(instance, onAfterClose) {
    setTimeout(function () {
      if (typeof onAfterClose === &#039;function&#039;) {
        onAfterClose();
      }

      instance._destroy();
    });
  };

  function setButtonsDisabled(instance, buttons, disabled) {
    var domCache = privateProps.domCache.get(instance);
    buttons.forEach(function (button) {
      domCache[button].disabled = disabled;
    });
  }

  function setInputDisabled(input, disabled) {
    if (!input) {
      return false;
    }

    if (input.type === &#039;radio&#039;) {
      var radiosContainer = input.parentNode.parentNode;
      var radios = radiosContainer.querySelectorAll(&#039;input&#039;);

      for (var i = 0; i &lt; radios.length; i++) {
        radios[i].disabled = disabled;
      }
    } else {
      input.disabled = disabled;
    }
  }

  function enableButtons() {
    setButtonsDisabled(this, [&#039;confirmButton&#039;, &#039;cancelButton&#039;], false);
  }
  function disableButtons() {
    setButtonsDisabled(this, [&#039;confirmButton&#039;, &#039;cancelButton&#039;], true);
  }
  function enableInput() {
    return setInputDisabled(this.getInput(), false);
  }
  function disableInput() {
    return setInputDisabled(this.getInput(), true);
  }

  function showValidationMessage(error) {
    var domCache = privateProps.domCache.get(this);
    setInnerHtml(domCache.validationMessage, error);
    var popupComputedStyle = window.getComputedStyle(domCache.popup);
    domCache.validationMessage.style.marginLeft = &quot;-&quot;.concat(popupComputedStyle.getPropertyValue(&#039;padding-left&#039;));
    domCache.validationMessage.style.marginRight = &quot;-&quot;.concat(popupComputedStyle.getPropertyValue(&#039;padding-right&#039;));
    show(domCache.validationMessage);
    var input = this.getInput();

    if (input) {
      input.setAttribute(&#039;aria-invalid&#039;, true);
      input.setAttribute(&#039;aria-describedBy&#039;, swalClasses[&#039;validation-message&#039;]);
      focusInput(input);
      addClass(input, swalClasses.inputerror);
    }
  } // Hide block with validation message

  function resetValidationMessage$1() {
    var domCache = privateProps.domCache.get(this);

    if (domCache.validationMessage) {
      hide(domCache.validationMessage);
    }

    var input = this.getInput();

    if (input) {
      input.removeAttribute(&#039;aria-invalid&#039;);
      input.removeAttribute(&#039;aria-describedBy&#039;);
      removeClass(input, swalClasses.inputerror);
    }
  }

  function getProgressSteps$1() {
    var domCache = privateProps.domCache.get(this);
    return domCache.progressSteps;
  }

  var Timer = /*#__PURE__*/function () {
    function Timer(callback, delay) {
      _classCallCheck(this, Timer);

      this.callback = callback;
      this.remaining = delay;
      this.running = false;
      this.start();
    }

    _createClass(Timer, [{
      key: &quot;start&quot;,
      value: function start() {
        if (!this.running) {
          this.running = true;
          this.started = new Date();
          this.id = setTimeout(this.callback, this.remaining);
        }

        return this.remaining;
      }
    }, {
      key: &quot;stop&quot;,
      value: function stop() {
        if (this.running) {
          this.running = false;
          clearTimeout(this.id);
          this.remaining -= new Date() - this.started;
        }

        return this.remaining;
      }
    }, {
      key: &quot;increase&quot;,
      value: function increase(n) {
        var running = this.running;

        if (running) {
          this.stop();
        }

        this.remaining += n;

        if (running) {
          this.start();
        }

        return this.remaining;
      }
    }, {
      key: &quot;getTimerLeft&quot;,
      value: function getTimerLeft() {
        if (this.running) {
          this.stop();
          this.start();
        }

        return this.remaining;
      }
    }, {
      key: &quot;isRunning&quot;,
      value: function isRunning() {
        return this.running;
      }
    }]);

    return Timer;
  }();

  var defaultInputValidators = {
    email: function email(string, validationMessage) {
      return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || &#039;Invalid email address&#039;);
    },
    url: function url(string, validationMessage) {
      // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013
      return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&amp;/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || &#039;Invalid URL&#039;);
    }
  };

  function setDefaultInputValidators(params) {
    // Use default `inputValidator` for supported input types if not provided
    if (!params.inputValidator) {
      Object.keys(defaultInputValidators).forEach(function (key) {
        if (params.input === key) {
          params.inputValidator = defaultInputValidators[key];
        }
      });
    }
  }

  function validateCustomTargetElement(params) {
    // Determine if the custom target element is valid
    if (!params.target || typeof params.target === &#039;string&#039; &amp;&amp; !document.querySelector(params.target) || typeof params.target !== &#039;string&#039; &amp;&amp; !params.target.appendChild) {
      warn(&#039;Target parameter is not valid, defaulting to &quot;body&quot;&#039;);
      params.target = &#039;body&#039;;
    }
  }
  /**
   * Set type, text and actions on popup
   *
   * @param params
   * @returns {boolean}
   */


  function setParameters(params) {
    setDefaultInputValidators(params); // showLoaderOnConfirm &amp;&amp; preConfirm

    if (params.showLoaderOnConfirm &amp;&amp; !params.preConfirm) {
      warn(&#039;showLoaderOnConfirm is set to true, but preConfirm is not defined.\n&#039; + &#039;showLoaderOnConfirm should be used together with preConfirm, see usage example:\n&#039; + &#039;https://sweetalert2.github.io/#ajax-request&#039;);
    } // params.animation will be actually used in renderPopup.js
    // but in case when params.animation is a function, we need to call that function
    // before popup (re)initialization, so it&#039;ll be possible to check Swal.isVisible()
    // inside the params.animation function


    params.animation = callIfFunction(params.animation);
    validateCustomTargetElement(params); // Replace newlines with &lt;br&gt; in title

    if (typeof params.title === &#039;string&#039;) {
      params.title = params.title.split(&#039;\n&#039;).join(&#039;&lt;br /&gt;&#039;);
    }

    init(params);
  }

  /**
   * Open popup, add necessary classes and styles, fix scrollbar
   *
   * @param {Array} params
   */

  var openPopup = function openPopup(params) {
    var container = getContainer();
    var popup = getPopup();

    if (typeof params.onBeforeOpen === &#039;function&#039;) {
      params.onBeforeOpen(popup);
    }

    var bodyStyles = window.getComputedStyle(document.body);
    var initialBodyOverflow = bodyStyles.overflowY;
    addClasses$1(container, popup, params); // scrolling is &#039;hidden&#039; until animation is done, after that &#039;auto&#039;

    setScrollingVisibility(container, popup);

    if (isModal()) {
      fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
      setAriaHidden();
    }

    if (!isToast() &amp;&amp; !globalState.previousActiveElement) {
      globalState.previousActiveElement = document.activeElement;
    }

    if (typeof params.onOpen === &#039;function&#039;) {
      setTimeout(function () {
        return params.onOpen(popup);
      });
    }

    removeClass(container, swalClasses[&#039;no-transition&#039;]);
  };

  function swalOpenAnimationFinished(event) {
    var popup = getPopup();

    if (event.target !== popup) {
      return;
    }

    var container = getContainer();
    popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
    container.style.overflowY = &#039;auto&#039;;
  }

  var setScrollingVisibility = function setScrollingVisibility(container, popup) {
    if (animationEndEvent &amp;&amp; hasCssAnimation(popup)) {
      container.style.overflowY = &#039;hidden&#039;;
      popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);
    } else {
      container.style.overflowY = &#039;auto&#039;;
    }
  };

  var fixScrollContainer = function fixScrollContainer(container, scrollbarPadding, initialBodyOverflow) {
    iOSfix();
    IEfix();

    if (scrollbarPadding &amp;&amp; initialBodyOverflow !== &#039;hidden&#039;) {
      fixScrollbar();
    } // sweetalert2/issues/1247


    setTimeout(function () {
      container.scrollTop = 0;
    });
  };

  var addClasses$1 = function addClasses(container, popup, params) {
    addClass(container, params.showClass.backdrop);
    show(popup); // Animate popup right after showing it

    addClass(popup, params.showClass.popup);
    addClass([document.documentElement, document.body], swalClasses.shown);

    if (params.heightAuto &amp;&amp; params.backdrop &amp;&amp; !params.toast) {
      addClass([document.documentElement, document.body], swalClasses[&#039;height-auto&#039;]);
    }
  };

  var handleInputOptionsAndValue = function handleInputOptionsAndValue(instance, params) {
    if (params.input === &#039;select&#039; || params.input === &#039;radio&#039;) {
      handleInputOptions(instance, params);
    } else if ([&#039;text&#039;, &#039;email&#039;, &#039;number&#039;, &#039;tel&#039;, &#039;textarea&#039;].indexOf(params.input) !== -1 &amp;&amp; (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
      handleInputValue(instance, params);
    }
  };
  var getInputValue = function getInputValue(instance, innerParams) {
    var input = instance.getInput();

    if (!input) {
      return null;
    }

    switch (innerParams.input) {
      case &#039;checkbox&#039;:
        return getCheckboxValue(input);

      case &#039;radio&#039;:
        return getRadioValue(input);

      case &#039;file&#039;:
        return getFileValue(input);

      default:
        return innerParams.inputAutoTrim ? input.value.trim() : input.value;
    }
  };

  var getCheckboxValue = function getCheckboxValue(input) {
    return input.checked ? 1 : 0;
  };

  var getRadioValue = function getRadioValue(input) {
    return input.checked ? input.value : null;
  };

  var getFileValue = function getFileValue(input) {
    return input.files.length ? input.getAttribute(&#039;multiple&#039;) !== null ? input.files : input.files[0] : null;
  };

  var handleInputOptions = function handleInputOptions(instance, params) {
    var content = getContent();

    var processInputOptions = function processInputOptions(inputOptions) {
      return populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);
    };

    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
      showLoading();
      asPromise(params.inputOptions).then(function (inputOptions) {
        instance.hideLoading();
        processInputOptions(inputOptions);
      });
    } else if (_typeof(params.inputOptions) === &#039;object&#039;) {
      processInputOptions(params.inputOptions);
    } else {
      error(&quot;Unexpected type of inputOptions! Expected object, Map or Promise, got &quot;.concat(_typeof(params.inputOptions)));
    }
  };

  var handleInputValue = function handleInputValue(instance, params) {
    var input = instance.getInput();
    hide(input);
    asPromise(params.inputValue).then(function (inputValue) {
      input.value = params.input === &#039;number&#039; ? parseFloat(inputValue) || 0 : &quot;&quot;.concat(inputValue);
      show(input);
      input.focus();
      instance.hideLoading();
    })[&quot;catch&quot;](function (err) {
      error(&quot;Error in inputValue promise: &quot;.concat(err));
      input.value = &#039;&#039;;
      show(input);
      input.focus();
      instance.hideLoading();
    });
  };

  var populateInputOptions = {
    select: function select(content, inputOptions, params) {
      var select = getChildByClass(content, swalClasses.select);

      var renderOption = function renderOption(parent, optionLabel, optionValue) {
        var option = document.createElement(&#039;option&#039;);
        option.value = optionValue;
        setInnerHtml(option, optionLabel);

        if (params.inputValue.toString() === optionValue.toString()) {
          option.selected = true;
        }

        parent.appendChild(option);
      };

      inputOptions.forEach(function (inputOption) {
        var optionValue = inputOption[0];
        var optionLabel = inputOption[1]; // &lt;optgroup&gt; spec:
        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6
        // &quot;...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...&quot;
        // check whether this is a &lt;optgroup&gt;

        if (Array.isArray(optionLabel)) {
          // if it is an array, then it is an &lt;optgroup&gt;
          var optgroup = document.createElement(&#039;optgroup&#039;);
          optgroup.label = optionValue;
          optgroup.disabled = false; // not configurable for now

          select.appendChild(optgroup);
          optionLabel.forEach(function (o) {
            return renderOption(optgroup, o[1], o[0]);
          });
        } else {
          // case of &lt;option&gt;
          renderOption(select, optionLabel, optionValue);
        }
      });
      select.focus();
    },
    radio: function radio(content, inputOptions, params) {
      var radio = getChildByClass(content, swalClasses.radio);
      inputOptions.forEach(function (inputOption) {
        var radioValue = inputOption[0];
        var radioLabel = inputOption[1];
        var radioInput = document.createElement(&#039;input&#039;);
        var radioLabelElement = document.createElement(&#039;label&#039;);
        radioInput.type = &#039;radio&#039;;
        radioInput.name = swalClasses.radio;
        radioInput.value = radioValue;

        if (params.inputValue.toString() === radioValue.toString()) {
          radioInput.checked = true;
        }

        var label = document.createElement(&#039;span&#039;);
        setInnerHtml(label, radioLabel);
        label.className = swalClasses.label;
        radioLabelElement.appendChild(radioInput);
        radioLabelElement.appendChild(label);
        radio.appendChild(radioLabelElement);
      });
      var radios = radio.querySelectorAll(&#039;input&#039;);

      if (radios.length) {
        radios[0].focus();
      }
    }
  };
  /**
   * Converts `inputOptions` into an array of `[value, label]`s
   * @param inputOptions
   */

  var formatInputOptions = function formatInputOptions(inputOptions) {
    var result = [];

    if (typeof Map !== &#039;undefined&#039; &amp;&amp; inputOptions instanceof Map) {
      inputOptions.forEach(function (value, key) {
        var valueFormatted = value;

        if (_typeof(valueFormatted) === &#039;object&#039;) {
          // case of &lt;optgroup&gt;
          valueFormatted = formatInputOptions(valueFormatted);
        }

        result.push([key, valueFormatted]);
      });
    } else {
      Object.keys(inputOptions).forEach(function (key) {
        var valueFormatted = inputOptions[key];

        if (_typeof(valueFormatted) === &#039;object&#039;) {
          // case of &lt;optgroup&gt;
          valueFormatted = formatInputOptions(valueFormatted);
        }

        result.push([key, valueFormatted]);
      });
    }

    return result;
  };

  var handleConfirmButtonClick = function handleConfirmButtonClick(instance, innerParams) {
    instance.disableButtons();

    if (innerParams.input) {
      handleConfirmWithInput(instance, innerParams);
    } else {
      confirm(instance, innerParams, true);
    }
  };
  var handleCancelButtonClick = function handleCancelButtonClick(instance, dismissWith) {
    instance.disableButtons();
    dismissWith(DismissReason.cancel);
  };

  var handleConfirmWithInput = function handleConfirmWithInput(instance, innerParams) {
    var inputValue = getInputValue(instance, innerParams);

    if (innerParams.inputValidator) {
      instance.disableInput();
      var validationPromise = Promise.resolve().then(function () {
        return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));
      });
      validationPromise.then(function (validationMessage) {
        instance.enableButtons();
        instance.enableInput();

        if (validationMessage) {
          instance.showValidationMessage(validationMessage);
        } else {
          confirm(instance, innerParams, inputValue);
        }
      });
    } else if (!instance.getInput().checkValidity()) {
      instance.enableButtons();
      instance.showValidationMessage(innerParams.validationMessage);
    } else {
      confirm(instance, innerParams, inputValue);
    }
  };

  var succeedWith = function succeedWith(instance, value) {
    instance.closePopup({
      value: value
    });
  };

  var confirm = function confirm(instance, innerParams, value) {
    if (innerParams.showLoaderOnConfirm) {
      showLoading(); // TODO: make showLoading an *instance* method
    }

    if (innerParams.preConfirm) {
      instance.resetValidationMessage();
      var preConfirmPromise = Promise.resolve().then(function () {
        return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));
      });
      preConfirmPromise.then(function (preConfirmValue) {
        if (isVisible(getValidationMessage()) || preConfirmValue === false) {
          instance.hideLoading();
        } else {
          succeedWith(instance, typeof preConfirmValue === &#039;undefined&#039; ? value : preConfirmValue);
        }
      });
    } else {
      succeedWith(instance, value);
    }
  };

  var addKeydownHandler = function addKeydownHandler(instance, globalState, innerParams, dismissWith) {
    if (globalState.keydownTarget &amp;&amp; globalState.keydownHandlerAdded) {
      globalState.keydownTarget.removeEventListener(&#039;keydown&#039;, globalState.keydownHandler, {
        capture: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = false;
    }

    if (!innerParams.toast) {
      globalState.keydownHandler = function (e) {
        return keydownHandler(instance, e, dismissWith);
      };

      globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
      globalState.keydownListenerCapture = innerParams.keydownListenerCapture;
      globalState.keydownTarget.addEventListener(&#039;keydown&#039;, globalState.keydownHandler, {
        capture: globalState.keydownListenerCapture
      });
      globalState.keydownHandlerAdded = true;
    }
  }; // Focus handling

  var setFocus = function setFocus(innerParams, index, increment) {
    var focusableElements = getFocusableElements(); // search for visible elements and select the next possible match

    for (var i = 0; i &lt; focusableElements.length; i++) {
      index = index + increment; // rollover to first item

      if (index === focusableElements.length) {
        index = 0; // go to last item
      } else if (index === -1) {
        index = focusableElements.length - 1;
      }

      return focusableElements[index].focus();
    } // no visible focusable elements, focus the popup


    getPopup().focus();
  };
  var arrowKeys = [&#039;ArrowLeft&#039;, &#039;ArrowRight&#039;, &#039;ArrowUp&#039;, &#039;ArrowDown&#039;, &#039;Left&#039;, &#039;Right&#039;, &#039;Up&#039;, &#039;Down&#039; // IE11
  ];
  var escKeys = [&#039;Escape&#039;, &#039;Esc&#039; // IE11
  ];

  var keydownHandler = function keydownHandler(instance, e, dismissWith) {
    var innerParams = privateProps.innerParams.get(instance);

    if (innerParams.stopKeydownPropagation) {
      e.stopPropagation();
    } // ENTER


    if (e.key === &#039;Enter&#039;) {
      handleEnter(instance, e, innerParams); // TAB
    } else if (e.key === &#039;Tab&#039;) {
      handleTab(e, innerParams); // ARROWS - switch focus between buttons
    } else if (arrowKeys.indexOf(e.key) !== -1) {
      handleArrows(); // ESC
    } else if (escKeys.indexOf(e.key) !== -1) {
      handleEsc(e, innerParams, dismissWith);
    }
  };

  var handleEnter = function handleEnter(instance, e, innerParams) {
    // #720 #721
    if (e.isComposing) {
      return;
    }

    if (e.target &amp;&amp; instance.getInput() &amp;&amp; e.target.outerHTML === instance.getInput().outerHTML) {
      if ([&#039;textarea&#039;, &#039;file&#039;].indexOf(innerParams.input) !== -1) {
        return; // do not submit
      }

      clickConfirm();
      e.preventDefault();
    }
  };

  var handleTab = function handleTab(e, innerParams) {
    var targetElement = e.target;
    var focusableElements = getFocusableElements();
    var btnIndex = -1;

    for (var i = 0; i &lt; focusableElements.length; i++) {
      if (targetElement === focusableElements[i]) {
        btnIndex = i;
        break;
      }
    }

    if (!e.shiftKey) {
      // Cycle to the next button
      setFocus(innerParams, btnIndex, 1);
    } else {
      // Cycle to the prev button
      setFocus(innerParams, btnIndex, -1);
    }

    e.stopPropagation();
    e.preventDefault();
  };

  var handleArrows = function handleArrows() {
    var confirmButton = getConfirmButton();
    var cancelButton = getCancelButton(); // focus Cancel button if Confirm button is currently focused

    if (document.activeElement === confirmButton &amp;&amp; isVisible(cancelButton)) {
      cancelButton.focus(); // and vice versa
    } else if (document.activeElement === cancelButton &amp;&amp; isVisible(confirmButton)) {
      confirmButton.focus();
    }
  };

  var handleEsc = function handleEsc(e, innerParams, dismissWith) {
    if (callIfFunction(innerParams.allowEscapeKey)) {
      e.preventDefault();
      dismissWith(DismissReason.esc);
    }
  };

  var handlePopupClick = function handlePopupClick(instance, domCache, dismissWith) {
    var innerParams = privateProps.innerParams.get(instance);

    if (innerParams.toast) {
      handleToastClick(instance, domCache, dismissWith);
    } else {
      // Ignore click events that had mousedown on the popup but mouseup on the container
      // This can happen when the user drags a slider
      handleModalMousedown(domCache); // Ignore click events that had mousedown on the container but mouseup on the popup

      handleContainerMousedown(domCache);
      handleModalClick(instance, domCache, dismissWith);
    }
  };

  var handleToastClick = function handleToastClick(instance, domCache, dismissWith) {
    // Closing toast by internal click
    domCache.popup.onclick = function () {
      var innerParams = privateProps.innerParams.get(instance);

      if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {
        return;
      }

      dismissWith(DismissReason.close);
    };
  };

  var ignoreOutsideClick = false;

  var handleModalMousedown = function handleModalMousedown(domCache) {
    domCache.popup.onmousedown = function () {
      domCache.container.onmouseup = function (e) {
        domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn&#039;t
        // have any other direct children aside of the popup

        if (e.target === domCache.container) {
          ignoreOutsideClick = true;
        }
      };
    };
  };

  var handleContainerMousedown = function handleContainerMousedown(domCache) {
    domCache.container.onmousedown = function () {
      domCache.popup.onmouseup = function (e) {
        domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup

        if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
          ignoreOutsideClick = true;
        }
      };
    };
  };

  var handleModalClick = function handleModalClick(instance, domCache, dismissWith) {
    domCache.container.onclick = function (e) {
      var innerParams = privateProps.innerParams.get(instance);

      if (ignoreOutsideClick) {
        ignoreOutsideClick = false;
        return;
      }

      if (e.target === domCache.container &amp;&amp; callIfFunction(innerParams.allowOutsideClick)) {
        dismissWith(DismissReason.backdrop);
      }
    };
  };

  function _main(userParams) {
    showWarningsForParams(userParams);

    if (globalState.currentInstance) {
      globalState.currentInstance._destroy();
    }

    globalState.currentInstance = this;
    var innerParams = prepareParams(userParams);
    setParameters(innerParams);
    Object.freeze(innerParams); // clear the previous timer

    if (globalState.timeout) {
      globalState.timeout.stop();
      delete globalState.timeout;
    } // clear the restore focus timeout


    clearTimeout(globalState.restoreFocusTimeout);
    var domCache = populateDomCache(this);
    render(this, innerParams);
    privateProps.innerParams.set(this, innerParams);
    return swalPromise(this, domCache, innerParams);
  }

  var prepareParams = function prepareParams(userParams) {
    var showClass = _extends({}, defaultParams.showClass, userParams.showClass);

    var hideClass = _extends({}, defaultParams.hideClass, userParams.hideClass);

    var params = _extends({}, defaultParams, userParams);

    params.showClass = showClass;
    params.hideClass = hideClass; // @deprecated

    if (userParams.animation === false) {
      params.showClass = {
        popup: &#039;swal2-noanimation&#039;,
        backdrop: &#039;swal2-noanimation&#039;
      };
      params.hideClass = {};
    }

    return params;
  };

  var swalPromise = function swalPromise(instance, domCache, innerParams) {
    return new Promise(function (resolve) {
      // functions to handle all closings/dismissals
      var dismissWith = function dismissWith(dismiss) {
        instance.closePopup({
          dismiss: dismiss
        });
      };

      privateMethods.swalPromiseResolve.set(instance, resolve);

      domCache.confirmButton.onclick = function () {
        return handleConfirmButtonClick(instance, innerParams);
      };

      domCache.cancelButton.onclick = function () {
        return handleCancelButtonClick(instance, dismissWith);
      };

      domCache.closeButton.onclick = function () {
        return dismissWith(DismissReason.close);
      };

      handlePopupClick(instance, domCache, dismissWith);
      addKeydownHandler(instance, globalState, innerParams, dismissWith);

      if (innerParams.toast &amp;&amp; (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {
        addClass(document.body, swalClasses[&#039;toast-column&#039;]);
      } else {
        removeClass(document.body, swalClasses[&#039;toast-column&#039;]);
      }

      handleInputOptionsAndValue(instance, innerParams);
      openPopup(innerParams);
      setupTimer(globalState, innerParams, dismissWith);
      initFocus(domCache, innerParams); // Scroll container to top on open (#1247, #1946)

      setTimeout(function () {
        domCache.container.scrollTop = 0;
      });
    });
  };

  var populateDomCache = function populateDomCache(instance) {
    var domCache = {
      popup: getPopup(),
      container: getContainer(),
      content: getContent(),
      actions: getActions(),
      confirmButton: getConfirmButton(),
      cancelButton: getCancelButton(),
      closeButton: getCloseButton(),
      validationMessage: getValidationMessage(),
      progressSteps: getProgressSteps()
    };
    privateProps.domCache.set(instance, domCache);
    return domCache;
  };

  var setupTimer = function setupTimer(globalState$$1, innerParams, dismissWith) {
    var timerProgressBar = getTimerProgressBar();
    hide(timerProgressBar);

    if (innerParams.timer) {
      globalState$$1.timeout = new Timer(function () {
        dismissWith(&#039;timer&#039;);
        delete globalState$$1.timeout;
      }, innerParams.timer);

      if (innerParams.timerProgressBar) {
        show(timerProgressBar);
        setTimeout(function () {
          if (globalState$$1.timeout.running) {
            // timer can be already stopped at this point
            animateTimerProgressBar(innerParams.timer);
          }
        });
      }
    }
  };

  var initFocus = function initFocus(domCache, innerParams) {
    if (innerParams.toast) {
      return;
    }

    if (!callIfFunction(innerParams.allowEnterKey)) {
      return blurActiveElement();
    }

    if (innerParams.focusCancel &amp;&amp; isVisible(domCache.cancelButton)) {
      return domCache.cancelButton.focus();
    }

    if (innerParams.focusConfirm &amp;&amp; isVisible(domCache.confirmButton)) {
      return domCache.confirmButton.focus();
    }

    setFocus(innerParams, -1, 1);
  };

  var blurActiveElement = function blurActiveElement() {
    if (document.activeElement &amp;&amp; typeof document.activeElement.blur === &#039;function&#039;) {
      document.activeElement.blur();
    }
  };

  /**
   * Updates popup parameters.
   */

  function update(params) {
    var popup = getPopup();
    var innerParams = privateProps.innerParams.get(this);

    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
      return warn(&quot;You&#039;re trying to update the closed or closing popup, that won&#039;t work. Use the update() method in preConfirm parameter or show a new popup.&quot;);
    }

    var validUpdatableParams = {}; // assign valid params from `params` to `defaults`

    Object.keys(params).forEach(function (param) {
      if (Swal.isUpdatableParameter(param)) {
        validUpdatableParams[param] = params[param];
      } else {
        warn(&quot;Invalid parameter to update: \&quot;&quot;.concat(param, &quot;\&quot;. Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js&quot;));
      }
    });

    var updatedParams = _extends({}, innerParams, validUpdatableParams);

    render(this, updatedParams);
    privateProps.innerParams.set(this, updatedParams);
    Object.defineProperties(this, {
      params: {
        value: _extends({}, this.params, params),
        writable: false,
        enumerable: true
      }
    });
  }

  function _destroy() {
    var domCache = privateProps.domCache.get(this);
    var innerParams = privateProps.innerParams.get(this);

    if (!innerParams) {
      return; // This instance has already been destroyed
    } // Check if there is another Swal closing


    if (domCache.popup &amp;&amp; globalState.swalCloseEventFinishedCallback) {
      globalState.swalCloseEventFinishedCallback();
      delete globalState.swalCloseEventFinishedCallback;
    } // Check if there is a swal disposal defer timer


    if (globalState.deferDisposalTimer) {
      clearTimeout(globalState.deferDisposalTimer);
      delete globalState.deferDisposalTimer;
    }

    if (typeof innerParams.onDestroy === &#039;function&#039;) {
      innerParams.onDestroy();
    }

    disposeSwal(this);
  }

  var disposeSwal = function disposeSwal(instance) {
    // Unset this.params so GC will dispose it (#1569)
    delete instance.params; // Unset globalState props so GC will dispose globalState (#1569)

    delete globalState.keydownHandler;
    delete globalState.keydownTarget; // Unset WeakMaps so GC will be able to dispose them (#1569)

    unsetWeakMaps(privateProps);
    unsetWeakMaps(privateMethods);
  };

  var unsetWeakMaps = function unsetWeakMaps(obj) {
    for (var i in obj) {
      obj[i] = new WeakMap();
    }
  };



  var instanceMethods = /*#__PURE__*/Object.freeze({
    hideLoading: hideLoading,
    disableLoading: hideLoading,
    getInput: getInput$1,
    close: close,
    closePopup: close,
    closeModal: close,
    closeToast: close,
    enableButtons: enableButtons,
    disableButtons: disableButtons,
    enableInput: enableInput,
    disableInput: disableInput,
    showValidationMessage: showValidationMessage,
    resetValidationMessage: resetValidationMessage$1,
    getProgressSteps: getProgressSteps$1,
    _main: _main,
    update: update,
    _destroy: _destroy
  });

  var currentInstance;

  var SweetAlert = /*#__PURE__*/function () {
    function SweetAlert() {
      _classCallCheck(this, SweetAlert);

      // Prevent run in Node env
      if (typeof window === &#039;undefined&#039;) {
        return;
      } // Check for the existence of Promise


      if (typeof Promise === &#039;undefined&#039;) {
        error(&#039;This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)&#039;);
      }

      currentInstance = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
      }

      var outerParams = Object.freeze(this.constructor.argsToParams(args));
      Object.defineProperties(this, {
        params: {
          value: outerParams,
          writable: false,
          enumerable: true,
          configurable: true
        }
      });

      var promise = this._main(this.params);

      privateProps.promise.set(this, promise);
    } // `catch` cannot be the name of a module export, so we define our thenable methods here instead


    _createClass(SweetAlert, [{
      key: &quot;then&quot;,
      value: function then(onFulfilled) {
        var promise = privateProps.promise.get(this);
        return promise.then(onFulfilled);
      }
    }, {
      key: &quot;finally&quot;,
      value: function _finally(onFinally) {
        var promise = privateProps.promise.get(this);
        return promise[&quot;finally&quot;](onFinally);
      }
    }]);

    return SweetAlert;
  }(); // Assign instance methods from src/instanceMethods/*.js to prototype


  _extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor


  _extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility


  Object.keys(instanceMethods).forEach(function (key) {
    SweetAlert[key] = function () {
      if (currentInstance) {
        var _currentInstance;

        return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
      }
    };
  });
  SweetAlert.DismissReason = DismissReason;
  SweetAlert.version = &#039;9.17.2&#039;;

  var Swal = SweetAlert;
  Swal[&quot;default&quot;] = Swal;

  return Swal;

}));
if (typeof this !== &#039;undefined&#039; &amp;&amp; this.Sweetalert2){  this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
